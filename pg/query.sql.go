// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package pg

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteUpload = `-- name: DeleteUpload :exec
DELETE FROM uploads WHERE id = $1
`

func (q *Queries) DeleteUpload(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUpload, id)
	return err
}

type InsertClosuresParams struct {
	ClosureNarHash string `json:"closure_nar_hash"`
	NarHash        string `json:"nar_hash"`
}

const insertUpload = `-- name: InsertUpload :one
INSERT INTO uploads (started_at, closure_nar_hash) VALUES ($1, $2) RETURNING id
`

type InsertUploadParams struct {
	StartedAt      pgtype.Timestamp `json:"started_at"`
	ClosureNarHash string           `json:"closure_nar_hash"`
}

func (q *Queries) InsertUpload(ctx context.Context, arg InsertUploadParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertUpload, arg.StartedAt, arg.ClosureNarHash)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const upsertClosure = `-- name: UpsertClosure :exec
INSERT INTO closures (nar_hash, updated_at)
VALUES ($1, $2)
ON CONFLICT (nar_hash)
DO UPDATE SET updated_at = $2
`

type UpsertClosureParams struct {
	NarHash   string           `json:"nar_hash"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpsertClosure(ctx context.Context, arg UpsertClosureParams) error {
	_, err := q.db.Exec(ctx, upsertClosure, arg.NarHash, arg.UpdatedAt)
	return err
}

const upsertObject = `-- name: UpsertObject :exec
INSERT INTO objects (nar_hash, reference_count)
VALUES ($1, 1)
ON CONFLICT (nar_hash)
DO UPDATE SET reference_count = objects.reference_count + 1
`

func (q *Queries) UpsertObject(ctx context.Context, narHash string) error {
	_, err := q.db.Exec(ctx, upsertObject, narHash)
	return err
}
