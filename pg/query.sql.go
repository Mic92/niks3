// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package pg

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const commitPendingClosure = `-- name: CommitPendingClosure :exec
SELECT commit_pending_closure($1::bigint)
`

func (q *Queries) CommitPendingClosure(ctx context.Context, dollar_1 int64) error {
	_, err := q.db.Exec(ctx, commitPendingClosure, dollar_1)
	return err
}

const getClosure = `-- name: GetClosure :one
SELECT updated_at FROM closures WHERE key = $1 LIMIT 1
`

func (q *Queries) GetClosure(ctx context.Context, key string) (pgtype.Timestamp, error) {
	row := q.db.QueryRow(ctx, getClosure, key)
	var updated_at pgtype.Timestamp
	err := row.Scan(&updated_at)
	return updated_at, err
}

const getClosureObjects = `-- name: GetClosureObjects :many
SELECT object_key FROM closure_objects WHERE closure_key = $1
`

func (q *Queries) GetClosureObjects(ctx context.Context, closureKey string) ([]string, error) {
	rows, err := q.db.Query(ctx, getClosureObjects, closureKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var object_key string
		if err := rows.Scan(&object_key); err != nil {
			return nil, err
		}
		items = append(items, object_key)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExistingObjects = `-- name: GetExistingObjects :many
SELECT key FROM objects WHERE key = ANY($1::varchar[])
`

func (q *Queries) GetExistingObjects(ctx context.Context, dollar_1 []string) ([]string, error) {
	rows, err := q.db.Query(ctx, getExistingObjects, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var key string
		if err := rows.Scan(&key); err != nil {
			return nil, err
		}
		items = append(items, key)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertPendingClosure = `-- name: InsertPendingClosure :one
INSERT INTO pending_closures (started_at, key) VALUES ($1, $2) RETURNING id
`

type InsertPendingClosureParams struct {
	StartedAt pgtype.Timestamp `json:"started_at"`
	Key       string           `json:"key"`
}

func (q *Queries) InsertPendingClosure(ctx context.Context, arg InsertPendingClosureParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertPendingClosure, arg.StartedAt, arg.Key)
	var id int64
	err := row.Scan(&id)
	return id, err
}

type InsertPendingObjectsParams struct {
	PendingClosureID int64  `json:"pending_closure_id"`
	Key              string `json:"key"`
}
