// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package pg

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteUpload = `-- name: DeleteUpload :exec
DELETE FROM uploads WHERE id = $1
`

func (q *Queries) DeleteUpload(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUpload, id)
	return err
}

type InsertClosuresParams struct {
	ClosureKey string `json:"closure_key"`
	ObjectKey  string `json:"object_key"`
}

const insertUpload = `-- name: InsertUpload :one
INSERT INTO uploads (started_at, closure_key) VALUES ($1, $2) RETURNING id
`

type InsertUploadParams struct {
	StartedAt  pgtype.Timestamp `json:"started_at"`
	ClosureKey string           `json:"closure_key"`
}

func (q *Queries) InsertUpload(ctx context.Context, arg InsertUploadParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertUpload, arg.StartedAt, arg.ClosureKey)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const upsertClosure = `-- name: UpsertClosure :exec
INSERT INTO closures (key, updated_at)
VALUES ($1, $2)
ON CONFLICT (key)
DO UPDATE SET updated_at = $2
`

type UpsertClosureParams struct {
	Key       string           `json:"key"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpsertClosure(ctx context.Context, arg UpsertClosureParams) error {
	_, err := q.db.Exec(ctx, upsertClosure, arg.Key, arg.UpdatedAt)
	return err
}

const upsertObject = `-- name: UpsertObject :exec
INSERT INTO objects (key, reference_count)
VALUES ($1, 1)
ON CONFLICT (key)
DO UPDATE SET reference_count = objects.reference_count + 1
`

func (q *Queries) UpsertObject(ctx context.Context, key string) error {
	_, err := q.db.Exec(ctx, upsertObject, key)
	return err
}
